2020 IEEE International Conference on Robotics and Automation (ICRA)
31 May - 31 August, 2020. Paris, France
Voxel-based General Voronoi Diagram for Complex Data with
Application on Motion Planning
Sebastian Dorn1, Nicola Wolpert2, and Elmar Scho¨mer3
Abstract—OnemajorchallengeinAssemblySequencePlan- planning,thecalculationoftheGVD[7],isdistributedtoall
ning (ASP) for complex real-world CAD-scenarios is to ﬁnd assembled parts.
appropriate disassembly paths for all assembled parts. Such a
The ordinary Voronoi Diagram (VD) is an important
path places demands on its length and clearance. In the past,
geometric data structure with a lot of applications [9]. For
it became apparent that planning the disassembly path based
on the (approximate) General Voronoi Diagram (GVD) is a a given set of sites the VD partitions the plane into regions
good approach to achieve these requirements. But for complex whereeverypointinaregionhasthesamenearestinputsite.
real-world data, every known solution for computing the GVD Intheordinarycasesitesarepoints.WegeneralizetheVDby
is either too slow or very memory consuming, even if only
regarding arbitrary 3D meshes as input sites. Our algorithm
approximating the GVD.
assumestheEuclideanmetric,butworkswithminorchanges
We present a new approach for computing the approximate
GVD and demonstrate its practicability using a representative for all Lp-norms.
vehicledataset.WecancalculateanapproximationoftheGVD Calculating the exact GVD is a very time consuming
withinminutesandmeettheaccuracyrequirementofsomefew task [10]. Since we focus on industrial data with millions of
millimeters for the subsequent path planning. This is achieved
triangles, we consider its approximation. The main criteria
by voxelizing the surface with a common error-bounded GPU
concerning practicability are calculation time and memory
render approach. We then use an error-bounded wavefront
propagationtechniqueandcombineitwithanovelhashtable- usage.
baseddatastructure,theso-calledVoronoiVoxelHistory(VVH). ThestateoftheartalgorithmsforapproximatingtheGVD
OntopoftheGVD,wepresentanovelapproachforthecreation can be divided into two main classes. The ﬁrst works with
of a General Voronoi Diagram Graph (GVDG) that leads to
the exact input data but approximates the GVD. We can
an extensive roadmap. For the later motion planning task this
subclassifythisinrender-andoctree-basedalgorithms.The
roadmapcanbeusedtosuggestappropriatedisassemblypaths.
second class approximates the input data with voxels and
I. INTRODUCTION calculates the distance ﬁeld that implicitly produces the
Assembly Sequence Planning (ASP) is an important task GVD.
in theory and practice [1], [2]. The subject of ASP is to ﬁnd Render-based approximation algorithms cut the scene in
at least one feasible assembly sequence for all assembled equidistant 2D slices, calculate the GVD for each slice
parts of an input assembly. For a general overview of ASP and stitch them together for achieving the three-dimensional
we refer to [3]. One of the main tasks in ASP is to ﬁnd GVD [23]. The GVD for one slice is calculated as follows:
an appropriate disassembly path for each assembled part For every site of the input meshes render the graph of a
to a possible destination. An appropriate disassembly path speciﬁc distance function - that is a hyperbolic function for
is short and has enough clearance to its surroundings [4]. a point, a cone for a line and a plane for the inner triangle
Moreover, a fast computation is crucial due to the numerous - and read out the z-Buffer. But rendering the graph of one
disassembly path queries performed in ASP. It turned out of the distance functions requires a facetted version of this
thatmotionplanningbasedontheGeneralVoronoiDiagram graph. This makes the approach too time consuming for an
(GVD) is a good approach to achieve these requirements input with millions of triangles.
[5], [7]. We consider the GVD in the three dimensional Another approach is based on octrees [20]. The main
workspacebecausetheone-timecalculatedGVDisthesame idea starts with one octree which includes the whole scene.
forallassembledparts.Thusitcanbeusedfortheassembly Theoctreerecursivelysubdividesitselfintoeightdescendant
of every part. Each part is an obstacle until it is going to be octrees if it includes more than one site or a neighbor octree
disassembled.Thenitchangesitsrolefromobstacletorobot. hasadifferentnearestsite.Thisproceedingterminatesifthe
After one part has been disassembled the GVD just needs a desired resolution is achieved. It results in a ﬁner resolution
simple update by reﬁlling the Voronoi cell of the removed at the Voronoi boundaries and a coarser one inside the
part. So the runtime bottleneck of GVD-based disassembly Voronoi cells. However, each time an octree is subdivided
into eight smaller ones, the nearest site must be calculated
1DigitalFactory,DaimlerAG,Germany foreachdescendant.Thisresultsinalotofdistancequeries,
sebastian.s.dorn@daimler.com
which makes this approach too slow for large input data.
2Department:Geomatics,ComputerScienceandMathematics,University
ofAppliedScienceStuttgart,Germany Distance ﬁeld approaches start with a uniform 3D voxel
nicola.wolpert@hft-stuttgart.de grid and use a scanning [11] or neighbor propagation
3Department: Physics, Mathematics and Computer Science, Johannes
technique [12]. These algorithms are fast because they have
Gutenberg-UniversityMainz,Germany
schoemer@informatik.uni-mainz.de linear computational costs in the number of voxels, but in
978-1-7281-7395-5/20/$31.00 ©2020 IEEE 137
Authorized licensed use limited to: University of New South Wales. Downloaded on September 20,2020 at 10:21:07 UTC from IEEE Xplore.  Restrictions apply. the 3D case, the memory usage is cubic. For a sufﬁcient still store the entire distance ﬁeld. In [19] a memory saving
resolution, this leads to an extensive memory usage. version of the Jump Flooding Algorithm [14] is presented.
In the distance ﬁeld, only the nearest site is stored as a
Our Contribution: Until now there is no runtime and short integer and therefore the memory saving factor of 6
memory efﬁcient algorithm for computing an approximate is achieved. But this only works for speciﬁc input sites and
GVD for complex real-world CAD-scenarios. Our approach still cannot eliminate the cubic memory usage of distance
uses the runtime efﬁcient concepts of voxelizing the input ﬁelds.
data and fast neighbor propagation. With our novel data
III. GENERALVORONOIDIAGRAM
structure, the Voronoi Voxel History (VVH), we keep the
memory utilization low. The idea is to store only the A. Setup
voxels needed for the current propagation step. These are We assume for the rest of this work that the input sites
mainly the voxels of the current wavefront which reduces are 3D meshes, each representing the body shell or one of
memory usage for most practical applications from cubic the assembled parts. All voxels v are positioned at v.pos
to quadratic. Our algorithm is robust in the sense that it in a Z3 grid. We use the Euclidean metric and deﬁne the
works with arbitrary meshes in arbitrary positions and is neighborhood N(v) of a voxel v as the union of the 26-
easy to implement. We also prove that the error of our neighborhood and the voxel itself. The discrete distance
approximationintheEuclideanmetricisatmost2.232times d:R3×R3 →N between two vectors a,b∈R3 is deﬁned
(cid:100)(cid:107)0− (cid:107) (cid:101)
the voxel size. In addition, we present the General Voronoi as d(a,b) := a b and the discrete distance of two
2
Diagram Graph (GVDG) which is extracted from the GVD. voxels v ,v as d(v ,v ):=d(v .pos,v .pos).
1 2 1 2 1 2
It is an extensive roadmap which can be used as a basis to
B. Main Idea
estimate reasonable disassembly paths for the later motion
planning task. At last, we test our proposed algorithms with The main idea of our solution is to use the speed advan-
different resolutions on a complex real-world data set from tage of a propagation method without storing the complete
the automotive industry. distance ﬁeld. The basic task during the propagation process
is to ﬁnd and check neighbors. In a complete distance ﬁeld
II. RELATEDWORK witha3Darrayrepresentation,thiscanbedonewithasimple
Inthelastdecadesmanyapproachesforapproximatingthe index shift. To compensate the missing complete 3D array,
GVD were presented. We give a comprehensive insight into we introduce our new data structure called Voronoi Voxel
the related work of the mentioned areas of render-, octree- History(VVH).TheVVHstoresthevoxelsofthelatestfew
and distance ﬁeld-based approaches. propagation steps in several hash tables. The access time of
O
Therender-basedapproach[23]isusedformanymotion a 3D array is (1) and on average this holds for the VVH
planning algorithms [7], [6], [5]. Based on this work the too. Our experiments show that the access time of our VVH
authors from [24] present an approximation for the distance increases just by a constant factor of 8 compared to a the
ﬁeld using arbitrary metrics for 2D data. In [25] there are access time of a distance ﬁeld.
some optimizations for the GVD visualization and shortest
C. The Algorithm
path queries. However, these works cannot overcome the
runtime explosion for complex input data. Our algorithm works in two steps. In the ﬁrst step we use
An extension of the basic work [20] on octrees is pre- the technique from [8] to voxelize the scene with a voxel
sented in [21]. The octree propagates the nearest site from resolution of λ>0. We render the scene in 2D slices, each
the parent to the descendant octrees. This leads to smarter of width λ, and interpret each colored pixel as a voxel that
belongstoasite.Differentcolorsrepresentthedifferentinput
nearestneighborqueries,wherenotallinputsiteshavetobe
sites. We call the colored voxels startingVoxels. They get
checked.Butforgeneralinputsites,itisstillcomputationally
stored in a ﬁrst hash table.
intensive. The focus in [22] is to compute the GVD for
Thesecondstepisthe propagationalgorithm.Weinitially
closelyspacedobjects.Theoctreedatastructureisoptimized
for this situation and works on arbitrary 3D meshes. This beginwiththestartingVoxelsandradius0andpropagatethe
voxels in discrete, radius increasing steps to their neighbors
approach cannot overcome the runtime problem with the
(for a graphical representation see Figure 1). This means
nearest neighbor query at each subdividing step.
Fortherelatedworkondistanceﬁeldsuntil2006werefer the radius r is both distance (measured in voxel size λ)
and time step. If a neighbor is visited the ﬁrst time the
to the extensive survey in [13]. The main techniques use
propagatingvoxelforwardstheinformationaboutitsstarting
distance templates, space scanning [11] or different voxel
propagation methods [12]. After this survey, some GPU- voxel (voxel.start), about the distance (voxel.dist) to its
starting voxel, and about the nearest site it belongs to
based propagation methods were introduced [14], [18], [15],
so that the propagation can be done in parallel which results (voxel.site) to the neighbor. If the neighbor was visited
before it is a candidate for the GVD.
in a signiﬁcant speed up. The authors from [17] present a
Wenowgiveadetaileddescriptionoftheproceeding.Also
divide and conquer algorithm on the GPU. There is also
consider the pseudocode in the right column.
a CPU based propagation algorithm with focus on fewer
distancecalculations[16].Butallofthepresentedalgorithms
138
Authorized licensed use limited to: University of New South Wales. Downloaded on September 20,2020 at 10:21:07 UTC from IEEE Xplore.  Restrictions apply. VoronoiVoxelHistory(VVH):Class1isourvoxelman- Class 1 VoronoiVoxelHistory
aging data structure. The variable data is a queue of 5 hash 1: Queue<HashTable<Voxel>> data
≤ ≤
tables(seeTheorem1).Thehashtableatposition1 i 5 2: function UPDATEVVH
stores for a given radius r ∈N all voxels with distance r+ 3: data.dequeue() (cid:46) delete oldest voxels
− 0
i 4.Wecallthehashtableatindexi=4currentVoxelsand 4: data.enqueue() (cid:46) add empty neighborVoxels
thehashtableatindexi=5neighborVoxels(foragraphical 5: function VOXELFINDVOXEL(x,y,z)
≤ ≤
representation see Figure 1 a)). The hash tables use separate 6: for 1 i 5 do
∈
chaining for collision resolution. A hash key for a voxel at 7: ifvoxel(x,y,z) data[i][hashkey(x,y,z)]then
∈Z
position(x,y,z) 3 which,amongothers,workedwellfor 8: return voxel
ourapplicationis(x3+y2+z+xyz) mod hashTable.size(). 9: return NULL
Attheendofonepropagationstep,thefunctionupdateVVH
(lines 2 - 4) clears the latest voxels (line 3), i.e. the voxels Algorithm 2 calculateGVD(startingVoxels)
withdistancer−3,andinsertsanewneighborVoxelshash 1: vvh←new VoronoiVoxelHistory
table (line 4). This represents an “aging” of 1 for all hash 2: vvh.currentVoxels←startingVoxels
tables.ThefunctionﬁndVoxel(x,y,z)searchesforthevoxel 3: r ←0 (cid:46) Initialize the radius
with the input coordinates (x,y,z) in the 5 hash tables of 4: while vvh.currentVoxels.size()>0 do
data and returns it. If the voxel is not stored yet it returns 5: vvh.setNeighborVoxelsSize()
NULL. 6: for all voxel←vvh.currentVoxels do
calculateGVD: Algorithm 2 takes the startingVoxels 7: propagateVoxel(vvh,voxel,r)
fromthevoxelizationstepasitsinput.WeinitializetheVVH ←
8: r r+1
(line 1), set the currentVoxels to the startingVoxels and
9: vvh.updateVVH()
the radius to r = 0 (lines 2, 3). The computation of the
GVD is ﬁnished when there are no more currentVoxels
in the VVH. The size of the hash table neighborVoxels Algorithm 3 propagateVo∈xe{l(−vvh,vo}xel,r)
is set to the number of voxels contained in currentVoxels 1: for all (∆←x,∆y,∆z) 1,0,1 3 do
(line 5). Since a current voxel has at most 27 neighbors, 2: nPos voxel.pos+(∆ ,∆ ,∆ )
(cid:54) x y z
this ensures a constant average query time for the new hash 3: if r+1=d(nPos,voxel.start.pos) then
table.Thefollowingloop(lines6,7)propagateseveryvoxel 4: continue
←
in currentVoxels, ﬁlling the neighborVoxels hash table. 5: n vvh.findVoxel(nPos)
When the propagation stops, propagation step r is ﬁnished 6: handleNeighbor(vvh,voxel,n,nPos)
and we update r and the VVH for the next step (lines 8, 9).
propagateVoxel: Algorithm 3 propagates a voxel to its Algorithm 4 handleNeighbor(vvh,voxel,n,nPos)
neighbors.ThepositionnPosoftheneighborissetinline2. 1: if n== NULL then
If the distance d from the neighbor position nPos to its 2: vvh.addNeighbor(voxel.start,nPos)
(cid:54)
starting voxel (voxel.start) is smaller than r+1 we visited 3: else if voxel.site =n.site
∨
this neighbor before. If d is greater than r +1 we would minDist<d(voxel.start,n.start) then
← ∪{ }
propagate too early. In both cases we discard this neighbor
4: GVD GVD voxel,n
(lines 3, 4). Otherwise we search the neighbor n at position 5: n.start← argmin (cid:107)n.pos−v.pos(cid:107)
nPos in data and call handleNeighbor (lines 5, 6). ∈{ } 2
v voxel.start,n.start
Note: In order to ensure that the propagation is always
correct we, in detail, propagate a voxel to all of its neighbor
From the approximate GVD obtained this way we can
voxels. If a neighbor voxel has a distance greater r+1 we
at the end derive a more speciﬁc approximation of the
store its starting voxel but it does not participate in the next
GVD by considering the intersections (see the dotted line
propagation step.
handleNeighbor:Weﬁrstcheckwhethertheneighborhas GVDintersection in Figure 1 b), which can be squares,
not been visited before (line 1). If yes, create and insert it lines or points in 3D) of all added voxel pairs voxel and n.
into the neighborVoxels hash table of the VVH (line 2). D. Analysis
If no, there are two different cases. First, if the nearest
It is important to guarantee that the propagation waves
sites of the voxel and its neighbor differ (ﬁrst condition in
from different starting voxels (as shown in Figure 1 b) for
line3)theconditionforaGVDvoxelissatisﬁedandweadd
the 2D case) do not propagate through each other. We show
both voxels to the GVD (line 4). Second, when the nearest
inTheorem 1thattheVVHstoresallneededvoxelsforthis.
sites (voxel.start.site, neighbor.start.site) are equal and
A visual representation is shown in Figure 2 a).
the distance of their starting voxels is greater than a given
parameter (second condition in line 3) we broaden the GVD Theorem 1: The VVH needs 5 hash tables for a correct
by also adding both voxels lying on the medial axis of the propagation process.
∈N
(large)inputsite.Finally,weupdatetheneareststartingvoxel Proof: Let r be the current propagation step and
0
n.start of n (line 5). v a current voxel with v.start = A that propagates to its
139
Authorized licensed use limited to: University of New South Wales. Downloaded on September 20,2020 at 10:21:07 UTC from IEEE Xplore.  Restrictions apply. a) so that every site and substantial subgeometry is intersected
A startingVoxel
by the rasterization.
discardedVoxels
A − Theorem 2: Letλ>0bethevoxelsize.Thentheapprox-
hashtable(r 3)
A A A A − imation of the GVD has an error of at most 2.232λ.
hashtable(r 2)
A A A A A − Proof: With a voxel size of λ and the render process
A A A A A A hashtable(r 1) in different directions (as described in [8])we can guarantee
A A A A A currentVoxels that the voxelization produces an error of at most λ/2 (for
A A A A
A neighborVoxels a graphical representation see Figure 2 b)).
A A A A ∈
Let a,b GVD be two neighbored voxels with different
b) GVDvoxels
starting voxels. We guarantee in Algorithm 3 (lines 3, 4)
GVDintersection that the discrete steps respect the Euclidean metric. So the
A
exact GVD of the starting voxels a.start and b.start passes
A A A A B B B B B
A A A A A B B B B B B somewhere through the union of the voxels a and b. By
A A A A A A B B B B B B B setting the approximate GVD to the intersection of a and b
A A A A A A A B B B B B B (see the dotted line GVDintersection√in Figure 1 b)) and
A A A A A A B B B B B by having a space diag√onal of length 3λ for a voxel we
A A A A A B B B B B get an error of at most 3λ. √
A ≈
A A A A B B B B B This yields an overall error of at most (1/2+ 3)λ
2.232λ.
Fig.1. a)AnillustrationofthedatastructureVVH.TheAinthelowerright
corner symbols the starting voxel (voxel.start) of the associated voxel.
ThediscardedVoxelsarenotstoredanymoreandtheneighborVoxels IV. GENERALVORONOIDIAGRAMGRAPH
are getting stored after the propagation step. b) The VVH data structure
As shown in [5], ﬁnding a disassembly path on a GVD-
afterthepropagationstepfromthecurrentVoxels.TheneighborVoxels
are now stored in the VVH. The GVDvoxels result from voxels with based roadmap, called General Voronoi Diagram Graph
different starting voxels (A and B) meeting during the propagation. The (GVDG), is runtime effective for ﬁnding short paths with
dashed line GVDintersection between the GVDvoxels represents the
non-volumetricboundaryoftheVoronoicells. sufﬁcientclearance.TheGVDGisanundirectedgraphG:=
(V,E)wherethesetofnodesV aswellasthesetofedgesE
a) b)
d(B,n) B arepartoftheGVD.O{nes∈traightforwarda≥ppro}achtodeﬁne
r+1 n nodes is to set V := v GVD : δ(v) 4 . All voxels
v − λ with∈deNgree δ(v) = 3 b∈elong to edges [7]. Here the degree
A r >r 1 δ(v) of∈a voxel v GVD is deﬁned by the number of
neighbors n N(v) with pairwise different nearest sites.
x
However, this approach ignores voxels v on the surfaces
Fig.2. a)Graphicalrepresentationofthevoxelvwhichpropagatestoits (δ(v)=2)andonthemedialaxis(δ(v)=1).Therefore,the
neighborn.b)Theresultoftherender-basedvoxelizationin+xdirection GVDG misses important edges with respect to path length
withvoxelsizeλ.Thereare4sliceswithwidthλand4pixelsperslice, andclearanceandisolatedsitescanoccur.Asitesisisolated
whereeachsliceisvisualizedbyaverticallineandthepixelsbythearrows.
if there is no path from boundary voxels of its Voronoi cell
Ifanarrowhitsthemesh,thecorrespondingpixelgetscolored.
toothernodesintheGVDG.ThishappensiftheGVDGhas
morethanoneconnectedcomponentoraVoronoicellhasno
neighborn.Thismeansthatd(A,v)=randd(A,n)=r+1. voxel v with δ(v)≥4. For a graphical representation of an
Now assume that n was visited before with n.start=B. isolated site in the two dimensional case see Figure 3. The
We want to prove that the information that n was visited shown site s has no voxel v on the boundary of its Voronoi
before is still stored in the VVH. ≥ ≥
cell with δ(v) 3 (δ(v) 4 in 3D). Thus no voxel of the
Since v ha−s A as its nearest starting voxel it follo(cid:108)ws t(cid:109)hat Voronoi cell of s is an element of V. Even if there would
d(B,v)>r 1. This leads to be a node, e.g. v , without respecting the medial axis for
√ 2
− ≤ ≤ the edges E the node v would have no connection to the
∈ 2
r 1<d(B,v) d(B,n)+d(v,n) d(B,n)+ 3 . node v V. It turns out that these cases often happen in
1
− complex real-world scenarios.
We derive d(B,n)>r 3. Unlikethestraightforwardapproach,ourapproachhandles
Under the assumption that we could compute the numer-
isolated sites and provides a detailed roadmap. We set the
ically correct distance between voxels it would be sufﬁcient { ∈ ≥ }
nodes V := v GVD : δ(v) 4 just like in the
tostoretheneighborVoxels(r+1−),thecurr−entVoxels(r) straightforward approach. If a site s has no voxel v on the
and the two previous hash tables r 1 and r 2. In order to boundary of its Voronoi cell with δ(v) ≥ 4 we add some
deal correctly with numerical inaccuracies one additionally
− voxels from the boundary with δ(v)<4 to the nodes V.
has to store the hash table r 3. To deﬁne the edges E, we start a simultaneous neighbor
∈
Next,weprovetheerror-boundfortheapproximationofour propagationontheGVDforeverynodev V.Avoxelv is
∩
GVD. We assume that the voxel size λ is sufﬁciently small onlyallowedtopropagatetothevoxelsN(v) GVD.Iftwo
140
Authorized licensed use limited to: University of New South Wales. Downloaded on September 20,2020 at 10:21:07 UTC from IEEE Xplore.  Restrictions apply. TABLEI
v v THEATTRIBUTESOFTHEDATASETS.
s 2 1
Test
#sites #triangles OBBsize[mm]
Data
body assembled
Fig. 3. A two dimensional assembly that shows four sites and the dataset shell parts assembly x y z
correspondingGVD.ThesolidlinerepresentstheboundaryoftheVoronoi a) 50 137 885,000 2,623 1,786 1,292
cellsandthedottedlinethemedialaxis.Thevoxelsv1andv2havedegree b) 692 1,036 12,168,000 4,617 1,991 1,317
δ(v2)=2andδ(v1)=3.
∈
propagating voxels v ,v GVD meet each other and their
1 2 ∈
starting voxels v .start,v .start V have no connecting
∈ 1 2
edge e E yet the edge is created. Since we also stored the
medial axis points in the GVD we can receive connections
between non-adjacent Voronoi cells. In addition, every site
∈
s contributes at least one node v V. The GVDG provides
a path for the site s starting from v to every node in V. a)
Here we exclude special cases like a site that is watertightly
enclosed by other sites (e.g. a sphere in a greater sphere).
V. EVALUATION
In this section we evaluate the GVD and the resulting
GVDG for different voxel sizes λ. The focus for the GVD
is on runtime and memory consumption. We compare the
number of used voxels of our approach with the ones used
by a complete distance ﬁeld. In the analysis of the GVDG
we consider the runtime, the size of the graph and the b)
number of isolated sites and compare it with the mentioned
straightforward approach [7]. In addition, paths proposed by
Fig.4. ThetestdatarepresenttwodifferentsubsetsoftheMercedes-Benz
a modiﬁed Dijkstra algorithm are evaluated.
A-Class. The blue sites belong to the body shell and the different-colored
The results are benchmarked on a laptop with an Intel onesaretheassembledsites.
i7-6820HQ (2.70GHz) processor, 32 GB of RAM and an
Table II. In addition, Figure 5 shows data set a) and our
NVIDIA Quadro M2000M graphics card. The software
computed GVD. We set the parameter minDist for the
(64bit binary) is written in C++ and compiled with MS
medial axis condition in Algorithm 4, line 3 to 50 mm.
Visual C++ 15.9. All algorithms use ﬂoating precision and
Column “t” contains the overall running time of our imple-
are executed, except the rendering step, on a single core of
mentationforvoxelizingthesceneandcalculatingtheGVD.
the CPU.
The voxelization step needs only a small percentage (<5%)
A. Test Data oftheoverallcalculationtime.WecancomputetheGVDfor
Weevaluateouralgorithmsbasedontwosubsetsofarep- the almost complete car in dataset b) with a high resolution
resentativereal-worlddatasetwhichcontainsahighnumber of λ= 5 mm in less than 25 minutes. Furthermore, the test
ofcomplexanddifferentlypositionedinputsites.Agraphical ondataseta)withλ=20mmandt=8secondsshowsthat
representationcanbefoundinFigure4.Theattributesofthe our approach is downscalable. Our algorithm has its focus
data are listed in Table I. Column “#sites” gives the number on the handling of very large and complex data but it is also
of input sites the body shell and all assembled sites consist usable for smaller datasets or coarser grids where the focus
of. “#triangles” shows the number of triangles of the whole is on a fast calculation time.
assembly (bodyshell and assembled sites). The dimensions The following two columns show the number of voxels
of the oriented bounding box containing the assembly are needed by our GVD and the complete distance ﬁeld (DF).
shown in “OBB size”. Data set b) contains with 1728 sites Regarding the space consumption of a single voxel, a voxel
consistingofover12milliontrianglesalmostallcomponents in the VVH needs to store its position (voxel.pos). This is
of a complete vehicle. Data set a) is a subset of b) and due to the unstructured ordering in the hash table and is not
is used to show the scalability of our algorithms. Since necessary for a distance ﬁeld. But since in our application
the slimmed down version is much more suitable for the the GVD or DF computation is only a preprocessing step
graphical representation of our results the following images for the subsequent GVDG calculation, it is recommended to
are based on data set a). equallystoreforeachvoxel:itsstartingvoxel(voxel.start),
its position (voxel.pos), its clearance (voxel.dist) and a list
B. General Voronoi Diagram
of neighboring voxels with different nearest sites. This has
The results of the tests for the GVD calculation are for the effect that the space consumption of a single voxel is
both data sets and with different voxel sizes presented in almost identical for both data structures.
141
Authorized licensed use limited to: University of New South Wales. Downloaded on September 20,2020 at 10:21:07 UTC from IEEE Xplore.  Restrictions apply. TABLEIII
THEEVALUATIONOFTHEGVDGCALCULATION.
λ | | | |
dataset [mm] t[s] V E isoSites saveDis
20 10 963 9,896 68 85
a) 10 6 633 6,816 54 106
5 15 318 3,598 50 108
20 298 17,126 111,290 636 341
b) 10 703 13,784 84,892 574 343
5 1463 9,339 48,574 601 400
Fig.5. Dataseta)anditsGVDwithavoxelsizeofλ=5mm.TheGVD
isrepresentedbytheboundariesofallVoronoicellswhicharecoloredthe
sameasthecorrespondinginputsite(seeFigure4a)).
TABLEII
THEEVALUATIONOFTHEGVDCALCULATION.
data GVD DF ratio
set λ[mm] t[s] #voxels #voxels #voxels
20 8 490,000 750,000 1.54
10 72 2,280,000 6,050,000 2.65
a)
5 525 13,580,000 48,420,000 3.56
2 11,687 68,478,000 756,575,000 11.04
20 25 1,080,000 1,510,000 1.39
b) 10 160 7,050,000 12,100,000 1.71
5 1,453 40,210,000 96,840,000 2.40
Therefore, the presented number of voxels for different
resolutionsinTableIIshowsthequadraticmemorygrowthof
our approachcompared withthe cubicgrowth ofa complete
distance ﬁeld. As a consequence, the “ratio” between the
number of voxels for a complete distance ﬁeld and for our
approach increases as the voxels become ﬁner. The need for
Fig.6. Above:ourcomputedGVDG.Below:theGVDGcomputedwith
a voxel saving approach becomes apparent for data set a)
the straightforward approach. The green squares represent example goals
with a voxel size of λ = 2 mm. Here the voxel ratio is fordisassemblypaths.
already 11.04. The DF approach had a constant calculation
planning in the close-up range from the installed position to
speed up of approximately 8.
a node of the GVDG is neglected.
A graphical representation of the GVDG is shown in
C. General Voronoi Diagram Graph
Figure 6. As a comparison, a graph based on the straightfor-
The results of the tests for computing the GVDG are
ward approach is created. One can see that our proceeding
shown in Table III. The column “t” shows the runtime for
provides a much more detailed roadmap which is able to
the GVDG calculation based on the GVD and a subsequent
reach all user-deﬁned goal nodes. The goal nodes represent
Dijkstra-based path search along the edges of the GVDG
the worker starting points around the car.
for each assembled and connected site. Whereby the path
search for a site s starts at the nodes of the corresponding VI. CONCLUSIONANDFUTUREWORK
Voronoi cell and ends by a worker starting point. We thined We presented an error-bounded approach for approximat-
out the set of nodes V by removing duplicate nodes, which ingtheGVDoftriangulated3DCAD-dataforallL -norms.
p
have another node within a small distance depending on Since it uses rendering and a fast propagation technique, it
| |
the voxel size. Therefore the number of nodes V varies. can compute results with a sufﬁcient resolution and running
Column “isoSites” shows the number of isolated sites of time. The main contribution of our work is a data structure
the straightforward approach. The high number shows that whichreducesthepreviouscubicmemoryusagetoquadratic
isolated sites often occur in complex scenarios. The number for our practical applications. Our experiments showed that
of isolated sites varies because sometimes very small sites this makes the propagation approach workable for complex
are not voxelized depending on the voxel size λ. The last real-worlddatalikeacompletecar.Inaddition,weproposed
column “saveDis” shows the number of sites for which the a detailed and connected roadmap, called GVDG, for sub-
pathsearchhasfoundasavedisassemblypathforwhichthe sequent motion planning. Based on our results we will in
clearance is greater than the diameter of the site. These sites thefutureevaluateGVD-basedmotionplannersforassembly
can be disassembled with no further check. Here the motion sequence planning.
142
Authorized licensed use limited to: University of New South Wales. Downloaded on September 20,2020 at 10:21:07 UTC from IEEE Xplore.  Restrictions apply. REFERENCES Visualization on Computer Graphics, vol. 12, no. 4, pp. 581-599,
July/August2006.
[14] G. Rong, T. Tan, “Jump Flooding in GPU with applications to
[1] T. Ebinger, S. Kaden, S. Thomas, R. Andre, N. M. Amato, and U.
Voronoi Diagram and distance transform,” Symposium of Interactive
Thomas, “A general and ﬂexible search framework for disassembly
3Dgraphicsandgames,pp.109-116,2006.
planning,” International Conference on Robotics and Automation
[15] J. Schneider, M. Kraus, and R. Westermann, “GPU-based real-time
(ICRA),pp.1-8,2018.
discrete euclidean distance transforms with precise error bounds,”
[2] I. Aguinaga, D. Borro, L. Matey, “Parallel RRT-based path planning
VISAPP,vol.8,pp.435-44,2009.
forselectivedisassemblyplanning,”InternationalJournalofAdvanced
[16] M.Velic,D.May,andL.Moresi,“Afastrobustalgorithmforcomput-
ManufacturingTechnology,pp.1221-1233,2008.
ing discrete Voronoi Diagrams,” Journal of Mathematical Modelling
[3] P. Jime´nez “Survey on assembly sequencing: a combinatorial and andAlgorithms,pp.343-355,2009.
geometrical perspective,” Journal of Intelligent Manufacturing, pp. [17] T.-T. Cao, K. Tang, A. Mohamed, and T.-S. Tan, “Parallel banding
235-250,April2013. algorithm to compute exact distance transform with the GPU,” SIG-
[4] M. Davoodi, F. Panahi, A. Mohades, S. N. Hashemi, “Clear and GRAPH,pp.83-90,2010.
smoothpathplanning,”AppliedSoftComputing,pp.568-579,2015. [18] L.Guo,F.Wang,Z.Huang,andN.Gu,“Afastandrobustseedﬂood-
[5] R.Geraerts,“Planningshortpathswithclearanceusingexplicitcorri- ingalgorithmonGPUforVoronoiDiagramgeneration,”International
dors,”InternationalConferenceonRoboticsandAutomation(ICRA), ConferenceonElectricalandControlEngineering,pp.492-495,2011.
pp.1997-2004,2010. [19] Z. Yuan, G. Rong, X. Guo, and W. Wang, “Generalized Voronoi
[6] M. Garber, M. C. Lin, “Constraint-based motion planning using DiagramcomputationonGPU,”InternationalSymposiumonVoronoi
Voronoi Diagrams,” International Conference on Robotics and Au- DiagramsinScienceandEngineering,2011.
tomation(ICRA),pp.541-558,2002. [20] D.Lavender,A.Bowyer,J.Davenport,A.Wallis,andJ.Woodwark,
[7] M. Foskey, M. Garber, M. C. Lin, D. Manocha, “A Voronoi-based “Voronoi Diagrams of set-theoretic solid models,” IEEE Comput.
hybridmotionplanner,”InternationalConferenceonIntelligentRobots Graph,pp.69-77,September1992.
andSystems,2001. [21] I.Baston,N.Celes,“Approximationof2dand3dgeneralizedVoronoi
[8] S.Fang,H.Chen“Hardwareacceleratedvoxelization,”SpringerTracts Diagrams,”InternationalJournalofComputerMathematics,pp.1003-
inAdvancedRobotics,pp.433-442,June2000. 1022,2008.
[9] A.Okabe,B.Boots,K.Sugihara,andS.N.Chiu“Spatialtessellations: [22] J. Edwards, E. Daniel, V. Pascucci and C. Bajaj, “Approximating
conceptsandapplicationsofVoronoiDiagrams,”2nded.,JohnWiley, theGeneralizedVoronoiDiagramofcloselyspacedobjects,”EURO-
Hoboken,NJ,2000. GRAPHICS,vol.34,no.2,2015.
[10] J.-D. Boissonnat, C. Wormser, and M. Yvinec, “Effective computa- [23] K.E.Hoff,J.Keyser,M.Lin,D.Manocha,andT.Culver,“Fastcom-
tionalgeometryforcurvesandsurfaces,”Springer,pp.67-116,2006. putation of generalized Voronoi Diagrams using graphics hardware,”
SIGGRAPH,pp.277-286,1999.
[11] P.-E. Danielsson, “Euclidean distance mapping,” Computer Graphics
[24] R.Strzodka,andA.Telea,“Generalizeddistancetransformsandskele-
andImageProcessing,pp.227-248,1980.
tonsingraphicshrdware,”IEEETCVGSymposiumonVisualization,
[12] I. Ragnemalm, “Fast erosion and dilation by contour processing and
pp.221-230,2004.
thresholding of distance maps,” Pettern Recognition Letters 13, pp.
[25] H.Hsieh,andW.Tai“AsimpleGPU-basedapproachfor3DVoronoi
161-166,1992.
diagramconstructionandvisualization,”SimulationModellingPratice
[13] M. W. Jones, J. A. Bærentzen, and M. Sramek, “3D distance ﬁelds:
andTheory,pp.681-692,September2005.
a survey of techniques and applications,” IEEE Transactions on
143
Authorized licensed use limited to: University of New South Wales. Downloaded on September 20,2020 at 10:21:07 UTC from IEEE Xplore.  Restrictions apply. 